"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeployments = void 0;
const ethers_1 = require("ethers");
const deployments_json_1 = __importDefault(require("../../../../deployments.json"));
const helpers_1 = require("../../helpers");
const Deployments = deployments_json_1.default;
const getDeployments = (args) => {
    const { chainInfo, isHub, useStaging, deployer: _deployer } = args;
    const chain = chainInfo.chain;
    const deployments = Deployments[chain];
    if (!deployments) {
        throw new Error(`No deployments found for chain ${chain}!`);
    }
    const contracts = deployments[0]["contracts"];
    if (!contracts) {
        throw new Error(`No contracts found under deployments for chain ${chain}!`);
    }
    const env = useStaging ? "Staging" : "";
    const deployer = _deployer.connect(chainInfo.rpc);
    // Get all the Hub connectors, if applicable.
    const connectors = [];
    if (isHub) {
        for (const key of Object.keys(contracts)) {
            // TODO: Use regex? Or a more flexible method?
            // Ignore accidental L2 or Spoke Connector deployments...
            if (key.includes("L2") || key.includes("Spoke")) {
                continue;
            }
            if (key.endsWith("Connector" + env) && !key.includes("Mainnet")) {
                const contract = contracts[key];
                connectors.push({
                    name: key,
                    address: contract.address,
                    abi: contract.abi,
                    contract: new ethers_1.Contract(contract.address, contract.abi, deployer),
                });
            }
        }
    }
    else {
        for (const key of Object.keys(contracts)) {
            if (key.endsWith("L2Connector" + env) || key.endsWith("SpokeConnector" + env)) {
                const contract = contracts[key];
                connectors.push({
                    name: key,
                    address: contract.address,
                    abi: contract.abi,
                    contract: new ethers_1.Contract(contract.address, contract.abi, deployer),
                });
            }
        }
        if (connectors.length > 1) {
            throw new Error(`Multiple L2/Spoke Connectors found on spoke chain ${chain} while consulting deployments.json! ` +
                "Please ensure outdated Connector deployment is deleted and removed.");
        }
    }
    return {
        Connext: (0, helpers_1.getContract)("Connext_DiamondProxy", chain, useStaging, deployer),
        messaging: isHub
            ? {
                RootManager: (0, helpers_1.getContract)("RootManager", chain, useStaging, deployer),
                MainnetConnector: (0, helpers_1.getContract)("MainnetSpokeConnector", chain, useStaging, deployer),
                WatcherManager: (0, helpers_1.getContract)("WatcherManager", chain, useStaging, deployer),
                HubConnectors: connectors,
                MerkleTreeManagerForRoot: (0, helpers_1.getContract)("MerkleTreeManagerRootUpgradeBeaconProxy", chain, useStaging, deployer),
                MerkleTreeManagerForSpoke: (0, helpers_1.getContract)("MerkleTreeManagerSpokeUpgradeBeaconProxy", chain, useStaging, deployer),
                RelayerProxy: (0, helpers_1.getContract)("RelayerProxyHub", chain, useStaging, deployer),
            }
            : {
                SpokeConnector: connectors[0],
                MerkleTreeManager: (0, helpers_1.getContract)("MerkleTreeManagerUpgradeBeaconProxy", chain, useStaging, deployer),
                WatcherManager: (0, helpers_1.getContract)("WatcherManager", chain, useStaging, deployer),
                RelayerProxy: (0, helpers_1.getContract)("RelayerProxy", chain, useStaging, deployer),
            },
    };
};
exports.getDeployments = getDeployments;
//# sourceMappingURL=deployments.js.map